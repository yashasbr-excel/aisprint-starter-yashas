---
alwaysApply: true
---

# Vercel AI SDK rules

## Installation/Updates

- use npm to install/update
- to install we need to ensure that core libraries are installed:
  npm install ai @ai-sdk/react @ai-sdk/openai zod

## Usage

- Prefer structured outputs. Sample backend code
- assume (but remind the user) to ensure they have set env variables like OPENAI_API_KEY
- separate file (e.g. in lib/recipe-schema.ts):

```
import { z } from 'zod';

/**
 * Defines the structure for a simple recipe.
 * This schema is passed to the AI to structure its response.
 */
export const RecipeSchema = z.object({
  title: z
    .string()
    .describe('The title of the recipe.'),
  prep_time_minutes: z
    .number()
    .describe('The preparation time in minutes.'),
  ingredients: z
    .array(z.string())
    .describe('A list of ingredients for the recipe.'),
  steps: z
    .array(z.string())
    .describe('The step-by-step instructions.'),
});

/**
 * We can also infer the TypeScript type directly from the schema.
 * This is useful for typing variables on both the client and server.
 */
export type Recipe = z.infer<typeof RecipeSchema>;
```

- import and use the schema to generate response in a route

```
import { openai } from '@ai-sdk/openai';
import { generateObject } from 'ai';
import { NextRequest, NextResponse } from 'next/server';

// 1. Import the Zod schema from its separate file
import { RecipeSchema } from '../../../lib/schemas';

export async function POST(req: NextRequest) {
  try {
    // Get the user's prompt from the request body
    const { topic } = await req.json();

    if (!topic) {
      return NextResponse.json({ error: 'Topic is required' }, { status: 400 });
    }

    // 2. Call generateObject and pass in the imported schema
    const { object } = await generateObject({
      model: openai('gpt-4o'), // Or your preferred model
      schema: RecipeSchema,   // Pass the schema here
      prompt: `Generate a simple recipe based on this topic: ${topic}.`,
    });

    // 3. Access the output from the response.
    // The 'object' is fully typed according to your RecipeSchema.
    console.log('Generated Recipe Title:', object.title);
    console.log('Ingredients:', object.ingredients.join(', '));

    // 4. Return the generated object as the API response.
    // The client will receive this JSON object.
    return NextResponse.json(object);

  } catch (error) {
    console.error(error);
    return NextResponse.json(
      { error: 'Failed to generate recipe' },
      { status: 500 }
    );
  }
}
```

- consume the response in the front-end

```
// This is a conceptual example for your frontend

import { useState } from 'react';
import { Recipe, RecipeSchema } from '../lib/schemas'; // <-- Reuse the schema!
import { z } from 'zod';

function RecipeGenerator() {
const [recipe, setRecipe] = useState<Recipe | null>(null);
const [isLoading, setIsLoading] = useState(false);

const handleSubmit = async (event: React.FormEvent) => {
event.preventDefault();
setIsLoading(true);
setRecipe(null);

    const response = await fetch('/api/generate-recipe', {
      method: 'POST',
      body: JSON.stringify({ topic: 'Chicken' }), // Example topic
    });

    if (!response.ok) {
      console.error('API call failed');
      setIsLoading(false);
      return;
    }

    const data = await response.json();

    // Use the schema to parse and validate the response
    // This guarantees 'parsed' is type-safe (Type: Recipe)
    try {
      const parsed = RecipeSchema.parse(data);
      setRecipe(parsed);
    } catch (error) {
      if (error instanceof z.ZodError) {
        console.error('Invalid response from AI:', error.errors);
      }
    }

    setIsLoading(false);

};

// ... rest of your component JSX to show the form and 'recipe'
}`

```
